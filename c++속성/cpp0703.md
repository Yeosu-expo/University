# 객체지향
## 객체
* 이 세상 모든 것들, 물리적이고 추상적인 모든 것들을 설명할 수 있음.
* class 형태로 구현
* class의 인스턴스 즉, class로 선언된 것을 객체라고 함.
```c++
  class Room{};
  
  int main(){
   Room room_1320;

   return 0;
  }
```
여기서 room_1320이 객체 혹은 인스턴스이다.
## class(강의실)
* 속성(컴퓨터, 책상, 칠판...)
* 기능(불켜기, 불끄기, 창문열기...)
* 각 속성의 세부속성과 기능은 또 다시 class로 정의됨(class desk)
* 그렇게 구현된 class를 다른 class에 사용할 수 있음(강의실 class에서desk class를 사용함)
* 상속
  * 속성과 기능이 비슷하거나 같은 class를 상위 class를 만들어서 그 속성과기능을 구현하고 하위 class에 상속함
  * 하위 class에 상위 class를 상속하면, 상위 class의 속성과 기능을 쓸 수있음

* 선언
```c++
class Circle{
   private:
      int radius;
   public:
      Circle(int r) { radius=r; }
      double getArea() { return 3.14*radius*radius; }
};
```

* private: 클래스 외부에서 사용할 수 없음
* public: 클래스 외부에서 사용할 수 있음
* 구분하는 이유는 고려하지 않아도 되는 변수나 기능을 private해줌으로써 사용자의 혼선을 막기위함(private는 상속되지 않음.)

# C++
* 기본적으로 C의 모든것을 쓸 수 있음 c 라이브러리도 포함.
* cout(console out)
  * cout << "문자열\n" ;
  * cout << "문자열" << endl;
  * 두 문장은 같은 기능을 수행
* namespace
  * 만약 프로젝트가 커지면, 함수나 변수의 이름이 겹칠 수 있음
  * 그 상태에서 프로그램을 실행하면 같은 이름의 함수나 변수가 충돌함
  * 그것을 방지하기 위해서 namespace를 사용하면 각 함수와 변수에 파일 단위로 앞에 별칭이 붙기 때문에 파일간의 충돌을 피할 수 있음

# 프로그래밍 언어 실행 과정
* cpu(register), ram, disk
* ram은 휘발성, disk는 비휘발성
* disk는 속도가 느리기 때문에 cpu에서 disk를 참조하면 읽는 동안 cpu는 동작하지 않는다.
* 그래서 cpu는 ram을 참조하고 disk로 바로 이어지지 않는다.
  
1. disk에 프로그래밍 파일이 있음
2. 프로그래밍 파일을 loader(disk의 특정위치를 읽고 ram에 특정위치에 쓰는 역할)가 ram에 어셈블리어로 해석해서 읽음
3. ram의 어셈블리어 명령을 cache가 기계어로 변환함
4. cpu가 cache에 기계어를 연산함

* 컴파일을 하는 방식이 프로그램마다 다르다.
* 프로그램에 비표준 문법이 있고, 그 문법을 사용하면 다른 프로그램으로 컴파일 할 수 없음.
* 마찬가지로 loader도 컴퓨터마다 다르게 동작할 수 있다.

# C언에서 추가된 기능
## 함수 중복
* 같은 기능을 사용하는 함수가 타입이나, 매개변수만 차이가 있을 때, 같으 함수 이름을 그대로 사용하여 변경사항을 수정해서 같은 함수 이름을 사용할 수 있음
## 디폴트 매개 변수(defalut parameter)
* 매개변수에 디폴트 값을 줘서 값이 들어오지 않았을 때, 디폴트 값으로 실행한다.
* 오버로딩으로 case를 나눠서 같은 효과를 낼 수 있음
## 참조와 참조 변수(reference)
* 변수의 선언 범위에 따라 참조하려면 주소값을 이용해야 됐는데, 이것을 해소해줌.
## 참조에 의한 호출(call-by-reference)

## new/delete 연산자
* c의 malloc, free와 같음
## 연산자 재정의
* 기존의 연산자의 기능을 새롭게 정의할 수 있음
## 제네릭 함수와 클래스
```c++
template<T>
T add(T num1, T num2){
   return num1+num2;
}
```
* 타입에 상관없는 함수를 만듦