# 객체지향 디자인
* 재활용성이 높은 코드를 작성해야 한다.
* 함수이름을 정할때는 getValue()처럼 동작이 먼저 명시되는 것이 좋다.
* 클래스이름은 MusicCheck처럼 객체가 더 먼저 명시 되는게 좋다.
* 한 프로젝트를 구현한다 했을 때, 클래스 선언부를 class.h파일로 만들고 클래스 구현부를 class.cpp로 만들고 이것을 집대성할 main.cpp를 만들어서 모든 cpp파일을 한번에 컴파일해서 실행하는 것이 좋다.
  * 이렇게 하는 것이 클래스 구현부, 선언부, main단위로 관리를 할 수 있기 때문에 유지보수 측면에서 유리하다.(현업에서는 이렇게 해야 함으로 이렇게 하자)
* 변수에 경우에는 보통 4바이트 내외지만, 클래스의 경우 덩치가 매우크다. 이 경우 객체를 그냥 선언하면 함수에서 이 객체 정보를 받아가면, 스택에 main의 객체랑 함수의 객체 총 두개의 객체 크기만큼 스택에 자리를 차지한다.
  * 이것을 해결하려면 객체를 포인터로 선언하고 new class를 줘서 객체를 동적할당해서 주소만 가지고 있고 함수에서 이 객체를 참조할 때 주소만 주면 힙에 객체 한개가 크기만큼 있고, 스택에는 주소 값만 두번 들어간다.

## 재활용성이 높은 객체지향 코딩 예시
예시로 노래정보를 저장하는 MusicInfo클래스와 음악 정보들을 바탕으로 퀴즈를 내는 MusicQuiz라는 클래스가 있다고 하자.

## 클래스 접근 지정자
* private
  * 부모 클래스의 private은 멤버 함수에서만 참조할 수 있고, 자식 클래스에서도 참조할 수 없다.
* public
  * 클래스의 정보를 모든 곳에서 참조할 수 있다.
* protected
  * 부모 클래스의 정보를 자식 클래스만 참조할 수 있다.

## call by value, address, reference
* call by value
  * 함수 호출시 매개변수의 값을 가진 새로운 메모리를 스택에 저장해 사용한다
  * int func(int a){}
* call by address
  * 함수 호출시 포인터 매개변수의 값(주소)를 가진 새로운 메모리를 스택에 저장해 사용한다
  * int func(int *a){}
* call by reference
  * 함수 호출시 인자의 메모리를 참조해서 사용한다
  * int func(int &a){}
* 공통점: value와 address는 값이든 주소이든 해당 값을 가진 새로운 메모리를 스택에 저장해 사용한다는 공통점이 있다.(이 경우 같은 값을 가진 변수를 스택에 두 번 쌓기 때문에 메모리 낭비가 있음)
* 차이점: value, address와 다르게 reference는 이미 스택에 있는 변수를 참조하기 때문에 스택에 새로운 메모리를 쌓지 않는다.(참조로 값을 변경할 수도 있음)

## 참조 리턴
* c는 함수의 반환 값이 기본 타입 값(int, float, char ...)과 포인터 값을 반환한다
* c++은 거기에 참조(reference)를 리턴할 수 있다.
```c++
#include <iostream>
using namespace std;

char& find(char s[], int index) {
	return s[index]; // 참조 리턴
}

int main() {
	char name[] = "Mike";
	cout << name << endl;

	find(name, 0) = 'S'; // name[0]='S'로 변경
	cout << name << endl;

	char& ref = find(name, 2); 
	ref = 't'; // name = "Site"
	cout << name << endl;
}
```
* 예시에서 보듯 find 함수가 문자열의 특정 문자 공간의 참조를 리턴한다.
* 리턴된 참조에 값을 넣으면, 해당 값이 바뀐다.

## 얕은복사와 깊은복사
* 얕은복사
  * 변수의 값을 복사할 때, 원본과 사본이 같은 메모리를 참조하는 방식으로 복사
  * 메모리를 공유하기 때문에 어느 한쪽에서 메모리 값을 변경하거나 삭제시 에러 발생
* 깊은복사
  * 변수의 값을 복사할 때, 원본과 사본이 값만 같고 다른 메모리를 가지게 복사
  * 메모리를 공유하지 않기 때문에, 메모리 공유 문제가 발생하지 않음

## 복사 생성자
* 생성자랑 중복으로 선언할 수 있다
```c++
Circle::Circle(Circle& c){
  this->radius=c.radius;
}

int main(){
  Circle src(30);
  Circle dest(src);

  return 0;
}
```
* 예시와 같이 선언하며, main에서 dest(src), 즉, 매개변수로 객체가 들어가면 실행된다.
* 주로 객체를 복사할 때, 사용한다. 
* 만약 복사 생성자를 선언하지 않으면, 자동으로 컴파일러가 복사 생성자를 적용해준다.
  * 이 경우 복사 생성자는 멤버변수를 복사해주는 기능을 수행한다.

### 복사 생성자 오류
* 디폴트 복사 생성자를 사용하거나, 구현부에서 얕은복사 방식으로 구현을 하게 되는 경우
* 원본과 사본이 같은 메모리를 참조하는 경우가 생김(주로 문자열을 복사할 때, 주소 값을 넘겨주기 때문에 이 경우 복사 생성자 오류에 해당됨)
* 원본과 사본 객체가 delete될 때, 한 쪽이 삭제되면 다른 한쪽이 삭제될 때, 삭제된 메모리 값을 참조함으로 오류 발생
* 해결 방법
  * 메모리를 참조하는 얕은복사 방식이 아닌, 값만 같고 독립적인 메모리를 가지는 깊은복사 방식의 복사 생성자를 구현한다.
  * 구체적으로 문자열의 경우 strcpy를 이용해서 값만 복사하는 것이 옳다.

## 함수 중복
* 기능: 같은 이름의 함수이지만, 매개 변수의 타입이나 개수에 따라 다른 기능을 수행할 수 있다.
* 매개변수의 타입과 개수가 같다면, 리턴타입이 달라도 함수 호출시 어떤 함수를 호출할지 정할 수 없어 오류가 난다.(함수 중복에서 어떤 함수를 수행할지 정하는 기준은 매개변수의 차이이기 때문)

### 함수 중복의 모호성
* 매개 변수 타입의 모호성
  * 만약 매개변수가 한 함수가 float형이고 다른 함수가 double형 일때, 매개변수 값으로 int형을 주면, float와 double형 모두 들어갈 수 있기 때문에 함수 호출을 할 수 없다. >> 컴파일 에러
* 매개 변수의 참조 모호성
  * 매개변수가 한 함수는 call by value 다른 함수는 call by reference라면 인자가 같기 때문에 컴파일 에러가 난다.
* 디폴트 매개변수로 인한 모호성
  * 디폴트 매개변수를 사용하면 값을 주지 않아도 실행된다. 그렇기 때문에 매개변수의 개수에 차이가 있더라도 디폴트 매개변수 때문에 매개변수의 개수에 차이를 구분할 수 없게 되는 경우 컴파일 에러가 난다.

## static
* 클래스 내에서 선언되며, private, pubulic 어느 곳에 선언되어 도 된다.
* static int a; static func(){}
* 클래스 멤버라고 부름. static이 아닌 멤버는 각 객체의 인스턴스 멤버라고 부름
* 프로그램 실행과 동시에 static 멤버 변수와 함수가 생성된다.
* 이때, 객체에 생성되는 것이 아닌 독립적인 메모리를 가진다.
* 따라서 객체가 소멸되어도 여전히 존재하고, 프로그램이 종료되어야 클래스 멤버로 소멸된다
* int Class::staticVar = 10; 을 하면, 초기 클래스 멤버 변수 생성시 해당 값으로 초기화 된다.
* 초기화하지 않으면 오류가 뜸
* 전역 변수임과 동시에 모든 객체가 공유하고 있는 멤버이기 때문에 호출하는 방식도 다르다.
  1. Class::staticVar = 100;
  2. obj.staticVar = 100; (객체에서 호출하는 경우)
  3. 두 방법 모두 결과는 같다
* static이 아닌 멤버는 모두 non-static이다
* static 멤버 함수는 non-static 멤버에 접근할 수 없다.(객체가 생성되지 않은 시점에서 static 멤버 함수가 호출되는 경우가 있을 수 있기 때문)
* static 멤버 함수는 this사용불가

### static 사용이유
* 전역 변수나 전역 함수를 클래스에 캡슐화
  * 전역 변수나 전역 함수를 가능한 사용하지 않도록
  * 전역 변수나 전역 함수를 static으로 선언하여 클래스 멤버로 선언
* 객체 사이에 공유 변수를 만들고자 할 때
  * static 멤버를 선언하여 모든 객체들이 공유

***
### tips
* 생성자가 정의되어 있다면, 클래스 선언시, 정의된 생성자만 호출한다. 그렇기 때문에 생성자가 매개변수가 제한되어 있으면, 그거에 맞지 않은 생성자 호출은 없는 생성자의 호출이기 때문에 오류가 뜬다.
* 가독성을 위해 간단한 코드를 함수로 정의했을 때, 만약 이 함수를 매우 많이 호출한다면, 함수 호출이 기본적으로 스택 덩치가 있기 때문에 스택 오버플로우가 날 수 있다. 이때, 함수 정의 앞에 inline을 붙여주면, 함수 실행시 함수 안에 코드를 그대로 가져오는 효과를 낸다. 즉, 함수 호출시 생기는 스택을 없앨 수 있다.