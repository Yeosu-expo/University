## STL
* Standard Template Library
* 제네릭 클래스와 함수를 포함하는 라이브러리. 즉, 자료형에 영향을 받지 않음
* 구성
  * 컨테이너
  * iterator
    * 컨테이너 원소를 참조하기 위한 포인터
  * 알고리즘(템플릿 함수)
    * 복사, 정렬, 찾기, 최대, 최소 등을 동작하는 함수들

### 컨테이너
* vector
  * 가변 길이 배열을 구현한 제네릭 클래스
* list
  * 배열의 형태가 아닌, 값을 저장하는 작은 공간들을 이어 붙이는 형식
  * linked list
* map
  * 키와 값으로 구성된 컨테이너
  * python의 dictionary와 같음
  * 키로 값을 접근하는 방식
  * 키와 값의 타입을 정의해주어야함. ex) map<int, string> m;
  * map은 기본적으로 키값으로 오름차순 정렬되어 있음.
  * 모든 키와 값을 참조하는 방법은 iterator를 begin부터 end까지 iterator->first는 키, iterator->second는 값을 참조하면 된다.

#### vector&list
* vector는 배열이기 때문에 값을 접근하는데에 빠름
* list는 작은 공간의 연속이기 때문에 중간에 삽입, 삭제가 빠름
* 반대로 vector는 삽입과 삭제시 모든 값을 당기고 밀어야해서 느림
* list는 배열처럼 인덱스 값으로 값을 접근하지 않기 때문에 값을 참조하는데 속도가 느림
* 이 장단점을 고려해서 컨테이너를 고르면 됨

### iterator
* c++에는 iterator라는 상위 클래스가 있다
* STL이 이 상위클래스를 상속받아 iterator를 각 컨테이너에 맞게 구현되어있다
* 더 자세한건 iterator 디자인패턴을 찾아보자

#### **업캐스팅의 중요성**
>> 하위 클래스를 상위 클래스로 바꿀 수 있기 때문에 모든 하위 클래스를 상위 클래스 배열에 넣어 한번에 관리할 수 있다.

#### tips
* 가상함수를 사용하는 오버라이딩은 자식클래스의 재정의된 함수만 쓰려할 때 사용한다
* 함수 재정의인 오버로딩은 부모 자식간의 계층 구조로 이루어지지 않고, 그냥 원본은 여러개로 재정의해서 이것도 쓰고 저것도 쓰고 할 때 사용함.
* if문을 계속 들어가는 코딩을 할때 enum으로 각 상태를 나눠서 구분하고 switch문으로 각 상태마다 코딩을 해줘서 코딩을 하면 하드코딩이지만, 더 관리하기 쉽다.(디자인 패턴)

